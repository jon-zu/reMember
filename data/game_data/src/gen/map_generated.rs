// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod re_member {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    pub enum Vec2Offset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Vec2<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Vec2<'a> {
        type Inner = Vec2<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Vec2<'a> {
        pub const VT_X: flatbuffers::VOffsetT = 4;
        pub const VT_Y: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Vec2 { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args Vec2Args,
        ) -> flatbuffers::WIPOffset<Vec2<'bldr>> {
            let mut builder = Vec2Builder::new(_fbb);
            builder.add_y(args.y);
            builder.add_x(args.x);
            builder.finish()
        }

        #[inline]
        pub fn x(&self) -> i32 {
            self._tab.get::<i32>(Vec2::VT_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn y(&self) -> i32 {
            self._tab.get::<i32>(Vec2::VT_Y, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Vec2<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("x", Self::VT_X, false)?
                .visit_field::<i32>("y", Self::VT_Y, false)?
                .finish();
            Ok(())
        }
    }
    pub struct Vec2Args {
        pub x: i32,
        pub y: i32,
    }
    impl<'a> Default for Vec2Args {
        #[inline]
        fn default() -> Self {
            Vec2Args { x: 0, y: 0 }
        }
    }

    pub struct Vec2Builder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Vec2Builder<'a, 'b> {
        #[inline]
        pub fn add_x(&mut self, x: i32) {
            self.fbb_.push_slot::<i32>(Vec2::VT_X, x, 0);
        }
        #[inline]
        pub fn add_y(&mut self, y: i32) {
            self.fbb_.push_slot::<i32>(Vec2::VT_Y, y, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Vec2Builder<'a, 'b> {
            let start = _fbb.start_table();
            Vec2Builder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Vec2<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Vec2<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Vec2");
            ds.field("x", &self.x());
            ds.field("y", &self.y());
            ds.finish()
        }
    }
    pub enum TileOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Tile<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Tile<'a> {
        type Inner = Tile<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Tile<'a> {
        pub const VT_NO: flatbuffers::VOffsetT = 4;
        pub const VT_X: flatbuffers::VOffsetT = 6;
        pub const VT_U: flatbuffers::VOffsetT = 8;
        pub const VT_Y: flatbuffers::VOffsetT = 10;
        pub const VT_Z_M: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Tile { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TileArgs<'args>,
        ) -> flatbuffers::WIPOffset<Tile<'bldr>> {
            let mut builder = TileBuilder::new(_fbb);
            builder.add_z_m(args.z_m);
            builder.add_y(args.y);
            if let Some(x) = args.u {
                builder.add_u(x);
            }
            builder.add_x(args.x);
            builder.add_no(args.no);
            builder.finish()
        }

        #[inline]
        pub fn no(&self) -> i32 {
            self._tab.get::<i32>(Tile::VT_NO, Some(0)).unwrap()
        }
        #[inline]
        pub fn x(&self) -> i32 {
            self._tab.get::<i32>(Tile::VT_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn u(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Tile::VT_U, None)
        }
        #[inline]
        pub fn y(&self) -> i32 {
            self._tab.get::<i32>(Tile::VT_Y, Some(0)).unwrap()
        }
        #[inline]
        pub fn z_m(&self) -> i32 {
            self._tab.get::<i32>(Tile::VT_Z_M, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Tile<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("no", Self::VT_NO, false)?
                .visit_field::<i32>("x", Self::VT_X, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("u", Self::VT_U, false)?
                .visit_field::<i32>("y", Self::VT_Y, false)?
                .visit_field::<i32>("z_m", Self::VT_Z_M, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TileArgs<'a> {
        pub no: i32,
        pub x: i32,
        pub u: Option<flatbuffers::WIPOffset<&'a str>>,
        pub y: i32,
        pub z_m: i32,
    }
    impl<'a> Default for TileArgs<'a> {
        #[inline]
        fn default() -> Self {
            TileArgs {
                no: 0,
                x: 0,
                u: None,
                y: 0,
                z_m: 0,
            }
        }
    }

    pub struct TileBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TileBuilder<'a, 'b> {
        #[inline]
        pub fn add_no(&mut self, no: i32) {
            self.fbb_.push_slot::<i32>(Tile::VT_NO, no, 0);
        }
        #[inline]
        pub fn add_x(&mut self, x: i32) {
            self.fbb_.push_slot::<i32>(Tile::VT_X, x, 0);
        }
        #[inline]
        pub fn add_u(&mut self, u: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Tile::VT_U, u);
        }
        #[inline]
        pub fn add_y(&mut self, y: i32) {
            self.fbb_.push_slot::<i32>(Tile::VT_Y, y, 0);
        }
        #[inline]
        pub fn add_z_m(&mut self, z_m: i32) {
            self.fbb_.push_slot::<i32>(Tile::VT_Z_M, z_m, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TileBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TileBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Tile<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Tile<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Tile");
            ds.field("no", &self.no());
            ds.field("x", &self.x());
            ds.field("u", &self.u());
            ds.field("y", &self.y());
            ds.field("z_m", &self.z_m());
            ds.finish()
        }
    }
    pub enum ReactorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Reactor<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Reactor<'a> {
        type Inner = Reactor<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Reactor<'a> {
        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_REACTOR_TIME: flatbuffers::VOffsetT = 6;
        pub const VT_X: flatbuffers::VOffsetT = 8;
        pub const VT_F: flatbuffers::VOffsetT = 10;
        pub const VT_NAME: flatbuffers::VOffsetT = 12;
        pub const VT_Y: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Reactor { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReactorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Reactor<'bldr>> {
            let mut builder = ReactorBuilder::new(_fbb);
            builder.add_y(args.y);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_f(args.f);
            builder.add_x(args.x);
            builder.add_reactor_time(args.reactor_time);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn id(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Reactor::VT_ID, None)
        }
        #[inline]
        pub fn reactor_time(&self) -> i32 {
            self._tab
                .get::<i32>(Reactor::VT_REACTOR_TIME, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn x(&self) -> i32 {
            self._tab.get::<i32>(Reactor::VT_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn f(&self) -> i32 {
            self._tab.get::<i32>(Reactor::VT_F, Some(0)).unwrap()
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Reactor::VT_NAME, None)
        }
        #[inline]
        pub fn y(&self) -> i32 {
            self._tab.get::<i32>(Reactor::VT_Y, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Reactor<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
                .visit_field::<i32>("reactor_time", Self::VT_REACTOR_TIME, false)?
                .visit_field::<i32>("x", Self::VT_X, false)?
                .visit_field::<i32>("f", Self::VT_F, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<i32>("y", Self::VT_Y, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ReactorArgs<'a> {
        pub id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub reactor_time: i32,
        pub x: i32,
        pub f: i32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub y: i32,
    }
    impl<'a> Default for ReactorArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReactorArgs {
                id: None,
                reactor_time: 0,
                x: 0,
                f: 0,
                name: None,
                y: 0,
            }
        }
    }

    pub struct ReactorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReactorBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Reactor::VT_ID, id);
        }
        #[inline]
        pub fn add_reactor_time(&mut self, reactor_time: i32) {
            self.fbb_
                .push_slot::<i32>(Reactor::VT_REACTOR_TIME, reactor_time, 0);
        }
        #[inline]
        pub fn add_x(&mut self, x: i32) {
            self.fbb_.push_slot::<i32>(Reactor::VT_X, x, 0);
        }
        #[inline]
        pub fn add_f(&mut self, f: i32) {
            self.fbb_.push_slot::<i32>(Reactor::VT_F, f, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Reactor::VT_NAME, name);
        }
        #[inline]
        pub fn add_y(&mut self, y: i32) {
            self.fbb_.push_slot::<i32>(Reactor::VT_Y, y, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReactorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReactorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Reactor<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Reactor<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Reactor");
            ds.field("id", &self.id());
            ds.field("reactor_time", &self.reactor_time());
            ds.field("x", &self.x());
            ds.field("f", &self.f());
            ds.field("name", &self.name());
            ds.field("y", &self.y());
            ds.finish()
        }
    }
    pub enum LifeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Life<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Life<'a> {
        type Inner = Life<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Life<'a> {
        pub const VT_RX_1: flatbuffers::VOffsetT = 4;
        pub const VT_Y: flatbuffers::VOffsetT = 6;
        pub const VT_CY: flatbuffers::VOffsetT = 8;
        pub const VT_F: flatbuffers::VOffsetT = 10;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 12;
        pub const VT_RX_0: flatbuffers::VOffsetT = 14;
        pub const VT_FH: flatbuffers::VOffsetT = 16;
        pub const VT_HIDE: flatbuffers::VOffsetT = 18;
        pub const VT_X: flatbuffers::VOffsetT = 20;
        pub const VT_ID: flatbuffers::VOffsetT = 22;
        pub const VT_MOB_TIME: flatbuffers::VOffsetT = 24;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Life { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LifeArgs<'args>,
        ) -> flatbuffers::WIPOffset<Life<'bldr>> {
            let mut builder = LifeBuilder::new(_fbb);
            builder.add_mob_time(args.mob_time);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.add_x(args.x);
            builder.add_hide(args.hide);
            builder.add_fh(args.fh);
            builder.add_rx_0(args.rx_0);
            if let Some(x) = args.type_ {
                builder.add_type_(x);
            }
            builder.add_f(args.f);
            builder.add_cy(args.cy);
            builder.add_y(args.y);
            builder.add_rx_1(args.rx_1);
            builder.finish()
        }

        #[inline]
        pub fn rx_1(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_RX_1, Some(0)).unwrap()
        }
        #[inline]
        pub fn y(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_Y, Some(0)).unwrap()
        }
        #[inline]
        pub fn cy(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_CY, Some(0)).unwrap()
        }
        #[inline]
        pub fn f(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_F, Some(0)).unwrap()
        }
        #[inline]
        pub fn type_(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Life::VT_TYPE_, None)
        }
        #[inline]
        pub fn rx_0(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_RX_0, Some(0)).unwrap()
        }
        #[inline]
        pub fn fh(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_FH, Some(0)).unwrap()
        }
        #[inline]
        pub fn hide(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_HIDE, Some(0)).unwrap()
        }
        #[inline]
        pub fn x(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn id(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Life::VT_ID, None)
        }
        #[inline]
        pub fn mob_time(&self) -> i32 {
            self._tab.get::<i32>(Life::VT_MOB_TIME, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Life<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("rx_1", Self::VT_RX_1, false)?
                .visit_field::<i32>("y", Self::VT_Y, false)?
                .visit_field::<i32>("cy", Self::VT_CY, false)?
                .visit_field::<i32>("f", Self::VT_F, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
                .visit_field::<i32>("rx_0", Self::VT_RX_0, false)?
                .visit_field::<i32>("fh", Self::VT_FH, false)?
                .visit_field::<i32>("hide", Self::VT_HIDE, false)?
                .visit_field::<i32>("x", Self::VT_X, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
                .visit_field::<i32>("mob_time", Self::VT_MOB_TIME, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LifeArgs<'a> {
        pub rx_1: i32,
        pub y: i32,
        pub cy: i32,
        pub f: i32,
        pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
        pub rx_0: i32,
        pub fh: i32,
        pub hide: i32,
        pub x: i32,
        pub id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub mob_time: i32,
    }
    impl<'a> Default for LifeArgs<'a> {
        #[inline]
        fn default() -> Self {
            LifeArgs {
                rx_1: 0,
                y: 0,
                cy: 0,
                f: 0,
                type_: None,
                rx_0: 0,
                fh: 0,
                hide: 0,
                x: 0,
                id: None,
                mob_time: 0,
            }
        }
    }

    pub struct LifeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LifeBuilder<'a, 'b> {
        #[inline]
        pub fn add_rx_1(&mut self, rx_1: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_RX_1, rx_1, 0);
        }
        #[inline]
        pub fn add_y(&mut self, y: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_Y, y, 0);
        }
        #[inline]
        pub fn add_cy(&mut self, cy: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_CY, cy, 0);
        }
        #[inline]
        pub fn add_f(&mut self, f: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_F, f, 0);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Life::VT_TYPE_, type_);
        }
        #[inline]
        pub fn add_rx_0(&mut self, rx_0: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_RX_0, rx_0, 0);
        }
        #[inline]
        pub fn add_fh(&mut self, fh: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_FH, fh, 0);
        }
        #[inline]
        pub fn add_hide(&mut self, hide: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_HIDE, hide, 0);
        }
        #[inline]
        pub fn add_x(&mut self, x: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_X, x, 0);
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Life::VT_ID, id);
        }
        #[inline]
        pub fn add_mob_time(&mut self, mob_time: i32) {
            self.fbb_.push_slot::<i32>(Life::VT_MOB_TIME, mob_time, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LifeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LifeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Life<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Life<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Life");
            ds.field("rx_1", &self.rx_1());
            ds.field("y", &self.y());
            ds.field("cy", &self.cy());
            ds.field("f", &self.f());
            ds.field("type_", &self.type_());
            ds.field("rx_0", &self.rx_0());
            ds.field("fh", &self.fh());
            ds.field("hide", &self.hide());
            ds.field("x", &self.x());
            ds.field("id", &self.id());
            ds.field("mob_time", &self.mob_time());
            ds.finish()
        }
    }
    pub enum PortalOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Portal<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Portal<'a> {
        type Inner = Portal<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Portal<'a> {
        pub const VT_TN: flatbuffers::VOffsetT = 4;
        pub const VT_HIDE_TOOLTIP: flatbuffers::VOffsetT = 6;
        pub const VT_PT: flatbuffers::VOffsetT = 8;
        pub const VT_TM: flatbuffers::VOffsetT = 10;
        pub const VT_HORIZONTAL_IMPACT: flatbuffers::VOffsetT = 12;
        pub const VT_Y: flatbuffers::VOffsetT = 14;
        pub const VT_X: flatbuffers::VOffsetT = 16;
        pub const VT_PN: flatbuffers::VOffsetT = 18;
        pub const VT_SCRIPT: flatbuffers::VOffsetT = 20;
        pub const VT_DELAY: flatbuffers::VOffsetT = 22;
        pub const VT_ONLY_ONCE: flatbuffers::VOffsetT = 24;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Portal { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PortalArgs<'args>,
        ) -> flatbuffers::WIPOffset<Portal<'bldr>> {
            let mut builder = PortalBuilder::new(_fbb);
            builder.add_only_once(args.only_once);
            builder.add_delay(args.delay);
            if let Some(x) = args.script {
                builder.add_script(x);
            }
            if let Some(x) = args.pn {
                builder.add_pn(x);
            }
            builder.add_x(args.x);
            builder.add_y(args.y);
            builder.add_horizontal_impact(args.horizontal_impact);
            builder.add_tm(args.tm);
            builder.add_pt(args.pt);
            builder.add_hide_tooltip(args.hide_tooltip);
            if let Some(x) = args.tn {
                builder.add_tn(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn tn(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Portal::VT_TN, None)
        }
        #[inline]
        pub fn hide_tooltip(&self) -> i32 {
            self._tab
                .get::<i32>(Portal::VT_HIDE_TOOLTIP, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn pt(&self) -> i32 {
            self._tab.get::<i32>(Portal::VT_PT, Some(0)).unwrap()
        }
        #[inline]
        pub fn tm(&self) -> i32 {
            self._tab.get::<i32>(Portal::VT_TM, Some(0)).unwrap()
        }
        #[inline]
        pub fn horizontal_impact(&self) -> i32 {
            self._tab
                .get::<i32>(Portal::VT_HORIZONTAL_IMPACT, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn y(&self) -> i32 {
            self._tab.get::<i32>(Portal::VT_Y, Some(0)).unwrap()
        }
        #[inline]
        pub fn x(&self) -> i32 {
            self._tab.get::<i32>(Portal::VT_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn pn(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Portal::VT_PN, None)
        }
        #[inline]
        pub fn script(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Portal::VT_SCRIPT, None)
        }
        #[inline]
        pub fn delay(&self) -> i32 {
            self._tab.get::<i32>(Portal::VT_DELAY, Some(0)).unwrap()
        }
        #[inline]
        pub fn only_once(&self) -> i32 {
            self._tab.get::<i32>(Portal::VT_ONLY_ONCE, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Portal<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tn", Self::VT_TN, false)?
                .visit_field::<i32>("hide_tooltip", Self::VT_HIDE_TOOLTIP, false)?
                .visit_field::<i32>("pt", Self::VT_PT, false)?
                .visit_field::<i32>("tm", Self::VT_TM, false)?
                .visit_field::<i32>("horizontal_impact", Self::VT_HORIZONTAL_IMPACT, false)?
                .visit_field::<i32>("y", Self::VT_Y, false)?
                .visit_field::<i32>("x", Self::VT_X, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pn", Self::VT_PN, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "script",
                    Self::VT_SCRIPT,
                    false,
                )?
                .visit_field::<i32>("delay", Self::VT_DELAY, false)?
                .visit_field::<i32>("only_once", Self::VT_ONLY_ONCE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PortalArgs<'a> {
        pub tn: Option<flatbuffers::WIPOffset<&'a str>>,
        pub hide_tooltip: i32,
        pub pt: i32,
        pub tm: i32,
        pub horizontal_impact: i32,
        pub y: i32,
        pub x: i32,
        pub pn: Option<flatbuffers::WIPOffset<&'a str>>,
        pub script: Option<flatbuffers::WIPOffset<&'a str>>,
        pub delay: i32,
        pub only_once: i32,
    }
    impl<'a> Default for PortalArgs<'a> {
        #[inline]
        fn default() -> Self {
            PortalArgs {
                tn: None,
                hide_tooltip: 0,
                pt: 0,
                tm: 0,
                horizontal_impact: 0,
                y: 0,
                x: 0,
                pn: None,
                script: None,
                delay: 0,
                only_once: 0,
            }
        }
    }

    pub struct PortalBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PortalBuilder<'a, 'b> {
        #[inline]
        pub fn add_tn(&mut self, tn: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Portal::VT_TN, tn);
        }
        #[inline]
        pub fn add_hide_tooltip(&mut self, hide_tooltip: i32) {
            self.fbb_
                .push_slot::<i32>(Portal::VT_HIDE_TOOLTIP, hide_tooltip, 0);
        }
        #[inline]
        pub fn add_pt(&mut self, pt: i32) {
            self.fbb_.push_slot::<i32>(Portal::VT_PT, pt, 0);
        }
        #[inline]
        pub fn add_tm(&mut self, tm: i32) {
            self.fbb_.push_slot::<i32>(Portal::VT_TM, tm, 0);
        }
        #[inline]
        pub fn add_horizontal_impact(&mut self, horizontal_impact: i32) {
            self.fbb_
                .push_slot::<i32>(Portal::VT_HORIZONTAL_IMPACT, horizontal_impact, 0);
        }
        #[inline]
        pub fn add_y(&mut self, y: i32) {
            self.fbb_.push_slot::<i32>(Portal::VT_Y, y, 0);
        }
        #[inline]
        pub fn add_x(&mut self, x: i32) {
            self.fbb_.push_slot::<i32>(Portal::VT_X, x, 0);
        }
        #[inline]
        pub fn add_pn(&mut self, pn: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Portal::VT_PN, pn);
        }
        #[inline]
        pub fn add_script(&mut self, script: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Portal::VT_SCRIPT, script);
        }
        #[inline]
        pub fn add_delay(&mut self, delay: i32) {
            self.fbb_.push_slot::<i32>(Portal::VT_DELAY, delay, 0);
        }
        #[inline]
        pub fn add_only_once(&mut self, only_once: i32) {
            self.fbb_
                .push_slot::<i32>(Portal::VT_ONLY_ONCE, only_once, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PortalBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PortalBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Portal<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Portal<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Portal");
            ds.field("tn", &self.tn());
            ds.field("hide_tooltip", &self.hide_tooltip());
            ds.field("pt", &self.pt());
            ds.field("tm", &self.tm());
            ds.field("horizontal_impact", &self.horizontal_impact());
            ds.field("y", &self.y());
            ds.field("x", &self.x());
            ds.field("pn", &self.pn());
            ds.field("script", &self.script());
            ds.field("delay", &self.delay());
            ds.field("only_once", &self.only_once());
            ds.finish()
        }
    }
    pub enum ObjOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Obj<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Obj<'a> {
        type Inner = Obj<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Obj<'a> {
        pub const VT_L_2: flatbuffers::VOffsetT = 4;
        pub const VT_L_0: flatbuffers::VOffsetT = 6;
        pub const VT_O_S: flatbuffers::VOffsetT = 8;
        pub const VT_R: flatbuffers::VOffsetT = 10;
        pub const VT_X: flatbuffers::VOffsetT = 12;
        pub const VT_Z: flatbuffers::VOffsetT = 14;
        pub const VT_F: flatbuffers::VOffsetT = 16;
        pub const VT_Y: flatbuffers::VOffsetT = 18;
        pub const VT_Z_M: flatbuffers::VOffsetT = 20;
        pub const VT_L_1: flatbuffers::VOffsetT = 22;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Obj { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ObjArgs<'args>,
        ) -> flatbuffers::WIPOffset<Obj<'bldr>> {
            let mut builder = ObjBuilder::new(_fbb);
            if let Some(x) = args.l_1 {
                builder.add_l_1(x);
            }
            builder.add_z_m(args.z_m);
            builder.add_y(args.y);
            builder.add_f(args.f);
            builder.add_z(args.z);
            builder.add_x(args.x);
            builder.add_r(args.r);
            if let Some(x) = args.o_s {
                builder.add_o_s(x);
            }
            if let Some(x) = args.l_0 {
                builder.add_l_0(x);
            }
            if let Some(x) = args.l_2 {
                builder.add_l_2(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn l_2(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Obj::VT_L_2, None)
        }
        #[inline]
        pub fn l_0(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Obj::VT_L_0, None)
        }
        #[inline]
        pub fn o_s(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Obj::VT_O_S, None)
        }
        #[inline]
        pub fn r(&self) -> i32 {
            self._tab.get::<i32>(Obj::VT_R, Some(0)).unwrap()
        }
        #[inline]
        pub fn x(&self) -> i32 {
            self._tab.get::<i32>(Obj::VT_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn z(&self) -> i32 {
            self._tab.get::<i32>(Obj::VT_Z, Some(0)).unwrap()
        }
        #[inline]
        pub fn f(&self) -> i32 {
            self._tab.get::<i32>(Obj::VT_F, Some(0)).unwrap()
        }
        #[inline]
        pub fn y(&self) -> i32 {
            self._tab.get::<i32>(Obj::VT_Y, Some(0)).unwrap()
        }
        #[inline]
        pub fn z_m(&self) -> i32 {
            self._tab.get::<i32>(Obj::VT_Z_M, Some(0)).unwrap()
        }
        #[inline]
        pub fn l_1(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Obj::VT_L_1, None)
        }
    }

    impl flatbuffers::Verifiable for Obj<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("l_2", Self::VT_L_2, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("l_0", Self::VT_L_0, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("o_s", Self::VT_O_S, false)?
                .visit_field::<i32>("r", Self::VT_R, false)?
                .visit_field::<i32>("x", Self::VT_X, false)?
                .visit_field::<i32>("z", Self::VT_Z, false)?
                .visit_field::<i32>("f", Self::VT_F, false)?
                .visit_field::<i32>("y", Self::VT_Y, false)?
                .visit_field::<i32>("z_m", Self::VT_Z_M, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("l_1", Self::VT_L_1, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ObjArgs<'a> {
        pub l_2: Option<flatbuffers::WIPOffset<&'a str>>,
        pub l_0: Option<flatbuffers::WIPOffset<&'a str>>,
        pub o_s: Option<flatbuffers::WIPOffset<&'a str>>,
        pub r: i32,
        pub x: i32,
        pub z: i32,
        pub f: i32,
        pub y: i32,
        pub z_m: i32,
        pub l_1: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ObjArgs<'a> {
        #[inline]
        fn default() -> Self {
            ObjArgs {
                l_2: None,
                l_0: None,
                o_s: None,
                r: 0,
                x: 0,
                z: 0,
                f: 0,
                y: 0,
                z_m: 0,
                l_1: None,
            }
        }
    }

    pub struct ObjBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ObjBuilder<'a, 'b> {
        #[inline]
        pub fn add_l_2(&mut self, l_2: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Obj::VT_L_2, l_2);
        }
        #[inline]
        pub fn add_l_0(&mut self, l_0: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Obj::VT_L_0, l_0);
        }
        #[inline]
        pub fn add_o_s(&mut self, o_s: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Obj::VT_O_S, o_s);
        }
        #[inline]
        pub fn add_r(&mut self, r: i32) {
            self.fbb_.push_slot::<i32>(Obj::VT_R, r, 0);
        }
        #[inline]
        pub fn add_x(&mut self, x: i32) {
            self.fbb_.push_slot::<i32>(Obj::VT_X, x, 0);
        }
        #[inline]
        pub fn add_z(&mut self, z: i32) {
            self.fbb_.push_slot::<i32>(Obj::VT_Z, z, 0);
        }
        #[inline]
        pub fn add_f(&mut self, f: i32) {
            self.fbb_.push_slot::<i32>(Obj::VT_F, f, 0);
        }
        #[inline]
        pub fn add_y(&mut self, y: i32) {
            self.fbb_.push_slot::<i32>(Obj::VT_Y, y, 0);
        }
        #[inline]
        pub fn add_z_m(&mut self, z_m: i32) {
            self.fbb_.push_slot::<i32>(Obj::VT_Z_M, z_m, 0);
        }
        #[inline]
        pub fn add_l_1(&mut self, l_1: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Obj::VT_L_1, l_1);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ObjBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ObjBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Obj<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Obj<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Obj");
            ds.field("l_2", &self.l_2());
            ds.field("l_0", &self.l_0());
            ds.field("o_s", &self.o_s());
            ds.field("r", &self.r());
            ds.field("x", &self.x());
            ds.field("z", &self.z());
            ds.field("f", &self.f());
            ds.field("y", &self.y());
            ds.field("z_m", &self.z_m());
            ds.field("l_1", &self.l_1());
            ds.finish()
        }
    }
    pub enum BackOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Back<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Back<'a> {
        type Inner = Back<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Back<'a> {
        pub const VT_Y: flatbuffers::VOffsetT = 4;
        pub const VT_CY: flatbuffers::VOffsetT = 6;
        pub const VT_A: flatbuffers::VOffsetT = 8;
        pub const VT_RX: flatbuffers::VOffsetT = 10;
        pub const VT_FRONT: flatbuffers::VOffsetT = 12;
        pub const VT_RY: flatbuffers::VOffsetT = 14;
        pub const VT_ANI: flatbuffers::VOffsetT = 16;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 18;
        pub const VT_X: flatbuffers::VOffsetT = 20;
        pub const VT_B_S: flatbuffers::VOffsetT = 22;
        pub const VT_CX: flatbuffers::VOffsetT = 24;
        pub const VT_F: flatbuffers::VOffsetT = 26;
        pub const VT_NO: flatbuffers::VOffsetT = 28;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Back { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BackArgs<'args>,
        ) -> flatbuffers::WIPOffset<Back<'bldr>> {
            let mut builder = BackBuilder::new(_fbb);
            builder.add_no(args.no);
            builder.add_f(args.f);
            builder.add_cx(args.cx);
            if let Some(x) = args.b_s {
                builder.add_b_s(x);
            }
            builder.add_x(args.x);
            builder.add_type_(args.type_);
            builder.add_ani(args.ani);
            builder.add_ry(args.ry);
            builder.add_front(args.front);
            builder.add_rx(args.rx);
            builder.add_a(args.a);
            builder.add_cy(args.cy);
            builder.add_y(args.y);
            builder.finish()
        }

        #[inline]
        pub fn y(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_Y, Some(0)).unwrap()
        }
        #[inline]
        pub fn cy(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_CY, Some(0)).unwrap()
        }
        #[inline]
        pub fn a(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_A, Some(0)).unwrap()
        }
        #[inline]
        pub fn rx(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_RX, Some(0)).unwrap()
        }
        #[inline]
        pub fn front(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_FRONT, Some(0)).unwrap()
        }
        #[inline]
        pub fn ry(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_RY, Some(0)).unwrap()
        }
        #[inline]
        pub fn ani(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_ANI, Some(0)).unwrap()
        }
        #[inline]
        pub fn type_(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_TYPE_, Some(0)).unwrap()
        }
        #[inline]
        pub fn x(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn b_s(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Back::VT_B_S, None)
        }
        #[inline]
        pub fn cx(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_CX, Some(0)).unwrap()
        }
        #[inline]
        pub fn f(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_F, Some(0)).unwrap()
        }
        #[inline]
        pub fn no(&self) -> i32 {
            self._tab.get::<i32>(Back::VT_NO, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Back<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("y", Self::VT_Y, false)?
                .visit_field::<i32>("cy", Self::VT_CY, false)?
                .visit_field::<i32>("a", Self::VT_A, false)?
                .visit_field::<i32>("rx", Self::VT_RX, false)?
                .visit_field::<i32>("front", Self::VT_FRONT, false)?
                .visit_field::<i32>("ry", Self::VT_RY, false)?
                .visit_field::<i32>("ani", Self::VT_ANI, false)?
                .visit_field::<i32>("type_", Self::VT_TYPE_, false)?
                .visit_field::<i32>("x", Self::VT_X, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("b_s", Self::VT_B_S, false)?
                .visit_field::<i32>("cx", Self::VT_CX, false)?
                .visit_field::<i32>("f", Self::VT_F, false)?
                .visit_field::<i32>("no", Self::VT_NO, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BackArgs<'a> {
        pub y: i32,
        pub cy: i32,
        pub a: i32,
        pub rx: i32,
        pub front: i32,
        pub ry: i32,
        pub ani: i32,
        pub type_: i32,
        pub x: i32,
        pub b_s: Option<flatbuffers::WIPOffset<&'a str>>,
        pub cx: i32,
        pub f: i32,
        pub no: i32,
    }
    impl<'a> Default for BackArgs<'a> {
        #[inline]
        fn default() -> Self {
            BackArgs {
                y: 0,
                cy: 0,
                a: 0,
                rx: 0,
                front: 0,
                ry: 0,
                ani: 0,
                type_: 0,
                x: 0,
                b_s: None,
                cx: 0,
                f: 0,
                no: 0,
            }
        }
    }

    pub struct BackBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BackBuilder<'a, 'b> {
        #[inline]
        pub fn add_y(&mut self, y: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_Y, y, 0);
        }
        #[inline]
        pub fn add_cy(&mut self, cy: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_CY, cy, 0);
        }
        #[inline]
        pub fn add_a(&mut self, a: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_A, a, 0);
        }
        #[inline]
        pub fn add_rx(&mut self, rx: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_RX, rx, 0);
        }
        #[inline]
        pub fn add_front(&mut self, front: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_FRONT, front, 0);
        }
        #[inline]
        pub fn add_ry(&mut self, ry: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_RY, ry, 0);
        }
        #[inline]
        pub fn add_ani(&mut self, ani: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_ANI, ani, 0);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_TYPE_, type_, 0);
        }
        #[inline]
        pub fn add_x(&mut self, x: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_X, x, 0);
        }
        #[inline]
        pub fn add_b_s(&mut self, b_s: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Back::VT_B_S, b_s);
        }
        #[inline]
        pub fn add_cx(&mut self, cx: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_CX, cx, 0);
        }
        #[inline]
        pub fn add_f(&mut self, f: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_F, f, 0);
        }
        #[inline]
        pub fn add_no(&mut self, no: i32) {
            self.fbb_.push_slot::<i32>(Back::VT_NO, no, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BackBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BackBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Back<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Back<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Back");
            ds.field("y", &self.y());
            ds.field("cy", &self.cy());
            ds.field("a", &self.a());
            ds.field("rx", &self.rx());
            ds.field("front", &self.front());
            ds.field("ry", &self.ry());
            ds.field("ani", &self.ani());
            ds.field("type_", &self.type_());
            ds.field("x", &self.x());
            ds.field("b_s", &self.b_s());
            ds.field("cx", &self.cx());
            ds.field("f", &self.f());
            ds.field("no", &self.no());
            ds.finish()
        }
    }
    pub enum LadderRopeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LadderRope<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LadderRope<'a> {
        type Inner = LadderRope<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> LadderRope<'a> {
        pub const VT_L: flatbuffers::VOffsetT = 4;
        pub const VT_PAGE: flatbuffers::VOffsetT = 6;
        pub const VT_X: flatbuffers::VOffsetT = 8;
        pub const VT_Y_2: flatbuffers::VOffsetT = 10;
        pub const VT_Y_1: flatbuffers::VOffsetT = 12;
        pub const VT_UF: flatbuffers::VOffsetT = 14;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LadderRope { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LadderRopeArgs,
        ) -> flatbuffers::WIPOffset<LadderRope<'bldr>> {
            let mut builder = LadderRopeBuilder::new(_fbb);
            builder.add_uf(args.uf);
            builder.add_y_1(args.y_1);
            builder.add_y_2(args.y_2);
            builder.add_x(args.x);
            builder.add_page(args.page);
            builder.add_l(args.l);
            builder.finish()
        }

        #[inline]
        pub fn l(&self) -> i32 {
            self._tab.get::<i32>(LadderRope::VT_L, Some(0)).unwrap()
        }
        #[inline]
        pub fn page(&self) -> i32 {
            self._tab.get::<i32>(LadderRope::VT_PAGE, Some(0)).unwrap()
        }
        #[inline]
        pub fn x(&self) -> i32 {
            self._tab.get::<i32>(LadderRope::VT_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn y_2(&self) -> i32 {
            self._tab.get::<i32>(LadderRope::VT_Y_2, Some(0)).unwrap()
        }
        #[inline]
        pub fn y_1(&self) -> i32 {
            self._tab.get::<i32>(LadderRope::VT_Y_1, Some(0)).unwrap()
        }
        #[inline]
        pub fn uf(&self) -> i32 {
            self._tab.get::<i32>(LadderRope::VT_UF, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for LadderRope<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("l", Self::VT_L, false)?
                .visit_field::<i32>("page", Self::VT_PAGE, false)?
                .visit_field::<i32>("x", Self::VT_X, false)?
                .visit_field::<i32>("y_2", Self::VT_Y_2, false)?
                .visit_field::<i32>("y_1", Self::VT_Y_1, false)?
                .visit_field::<i32>("uf", Self::VT_UF, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LadderRopeArgs {
        pub l: i32,
        pub page: i32,
        pub x: i32,
        pub y_2: i32,
        pub y_1: i32,
        pub uf: i32,
    }
    impl<'a> Default for LadderRopeArgs {
        #[inline]
        fn default() -> Self {
            LadderRopeArgs {
                l: 0,
                page: 0,
                x: 0,
                y_2: 0,
                y_1: 0,
                uf: 0,
            }
        }
    }

    pub struct LadderRopeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LadderRopeBuilder<'a, 'b> {
        #[inline]
        pub fn add_l(&mut self, l: i32) {
            self.fbb_.push_slot::<i32>(LadderRope::VT_L, l, 0);
        }
        #[inline]
        pub fn add_page(&mut self, page: i32) {
            self.fbb_.push_slot::<i32>(LadderRope::VT_PAGE, page, 0);
        }
        #[inline]
        pub fn add_x(&mut self, x: i32) {
            self.fbb_.push_slot::<i32>(LadderRope::VT_X, x, 0);
        }
        #[inline]
        pub fn add_y_2(&mut self, y_2: i32) {
            self.fbb_.push_slot::<i32>(LadderRope::VT_Y_2, y_2, 0);
        }
        #[inline]
        pub fn add_y_1(&mut self, y_1: i32) {
            self.fbb_.push_slot::<i32>(LadderRope::VT_Y_1, y_1, 0);
        }
        #[inline]
        pub fn add_uf(&mut self, uf: i32) {
            self.fbb_.push_slot::<i32>(LadderRope::VT_UF, uf, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LadderRopeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LadderRopeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LadderRope<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LadderRope<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LadderRope");
            ds.field("l", &self.l());
            ds.field("page", &self.page());
            ds.field("x", &self.x());
            ds.field("y_2", &self.y_2());
            ds.field("y_1", &self.y_1());
            ds.field("uf", &self.uf());
            ds.finish()
        }
    }
    pub enum ExtraOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Extra<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Extra<'a> {
        type Inner = Extra<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Extra<'a> {
        pub const VT_INFO: flatbuffers::VOffsetT = 4;
        pub const VT_OBJ: flatbuffers::VOffsetT = 6;
        pub const VT_TILE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Extra { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ExtraArgs<'args>,
        ) -> flatbuffers::WIPOffset<Extra<'bldr>> {
            let mut builder = ExtraBuilder::new(_fbb);
            if let Some(x) = args.tile {
                builder.add_tile(x);
            }
            if let Some(x) = args.obj {
                builder.add_obj(x);
            }
            if let Some(x) = args.info {
                builder.add_info(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn info(&self) -> Option<Info<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Info>>(Extra::VT_INFO, None)
        }
        #[inline]
        pub fn obj(&self) -> Option<Obj<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Obj>>(Extra::VT_OBJ, None)
        }
        #[inline]
        pub fn tile(&self) -> Option<Tile<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Tile>>(Extra::VT_TILE, None)
        }
    }

    impl flatbuffers::Verifiable for Extra<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Info>>("info", Self::VT_INFO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Obj>>("obj", Self::VT_OBJ, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Tile>>("tile", Self::VT_TILE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ExtraArgs<'a> {
        pub info: Option<flatbuffers::WIPOffset<Info<'a>>>,
        pub obj: Option<flatbuffers::WIPOffset<Obj<'a>>>,
        pub tile: Option<flatbuffers::WIPOffset<Tile<'a>>>,
    }
    impl<'a> Default for ExtraArgs<'a> {
        #[inline]
        fn default() -> Self {
            ExtraArgs {
                info: None,
                obj: None,
                tile: None,
            }
        }
    }

    pub struct ExtraBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ExtraBuilder<'a, 'b> {
        #[inline]
        pub fn add_info(&mut self, info: flatbuffers::WIPOffset<Info<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Info>>(Extra::VT_INFO, info);
        }
        #[inline]
        pub fn add_obj(&mut self, obj: flatbuffers::WIPOffset<Obj<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Obj>>(Extra::VT_OBJ, obj);
        }
        #[inline]
        pub fn add_tile(&mut self, tile: flatbuffers::WIPOffset<Tile<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Tile>>(Extra::VT_TILE, tile);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExtraBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ExtraBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Extra<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Extra<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Extra");
            ds.field("info", &self.info());
            ds.field("obj", &self.obj());
            ds.field("tile", &self.tile());
            ds.finish()
        }
    }
    pub enum SeatOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Seat<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Seat<'a> {
        type Inner = Seat<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Seat<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Seat { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SeatArgs,
        ) -> flatbuffers::WIPOffset<Seat<'bldr>> {
            let mut builder = SeatBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for Seat<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SeatArgs {}
    impl<'a> Default for SeatArgs {
        #[inline]
        fn default() -> Self {
            SeatArgs {}
        }
    }

    pub struct SeatBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SeatBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SeatBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SeatBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Seat<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Seat<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Seat");
            ds.finish()
        }
    }
    pub enum FootholdOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Foothold<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Foothold<'a> {
        type Inner = Foothold<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Foothold<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Foothold { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args FootholdArgs,
        ) -> flatbuffers::WIPOffset<Foothold<'bldr>> {
            let mut builder = FootholdBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for Foothold<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct FootholdArgs {}
    impl<'a> Default for FootholdArgs {
        #[inline]
        fn default() -> Self {
            FootholdArgs {}
        }
    }

    pub struct FootholdBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FootholdBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FootholdBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FootholdBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Foothold<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Foothold<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Foothold");
            ds.finish()
        }
    }
    pub enum MiniMapOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MiniMap<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MiniMap<'a> {
        type Inner = MiniMap<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> MiniMap<'a> {
        pub const VT_CENTER_Y: flatbuffers::VOffsetT = 4;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
        pub const VT_MAG: flatbuffers::VOffsetT = 8;
        pub const VT_CENTER_X: flatbuffers::VOffsetT = 10;
        pub const VT_WIDTH: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MiniMap { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MiniMapArgs,
        ) -> flatbuffers::WIPOffset<MiniMap<'bldr>> {
            let mut builder = MiniMapBuilder::new(_fbb);
            builder.add_width(args.width);
            builder.add_center_x(args.center_x);
            builder.add_mag(args.mag);
            builder.add_height(args.height);
            builder.add_center_y(args.center_y);
            builder.finish()
        }

        #[inline]
        pub fn center_y(&self) -> i32 {
            self._tab.get::<i32>(MiniMap::VT_CENTER_Y, Some(0)).unwrap()
        }
        #[inline]
        pub fn height(&self) -> i32 {
            self._tab.get::<i32>(MiniMap::VT_HEIGHT, Some(0)).unwrap()
        }
        #[inline]
        pub fn mag(&self) -> i32 {
            self._tab.get::<i32>(MiniMap::VT_MAG, Some(0)).unwrap()
        }
        #[inline]
        pub fn center_x(&self) -> i32 {
            self._tab.get::<i32>(MiniMap::VT_CENTER_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn width(&self) -> i32 {
            self._tab.get::<i32>(MiniMap::VT_WIDTH, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for MiniMap<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("center_y", Self::VT_CENTER_Y, false)?
                .visit_field::<i32>("height", Self::VT_HEIGHT, false)?
                .visit_field::<i32>("mag", Self::VT_MAG, false)?
                .visit_field::<i32>("center_x", Self::VT_CENTER_X, false)?
                .visit_field::<i32>("width", Self::VT_WIDTH, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MiniMapArgs {
        pub center_y: i32,
        pub height: i32,
        pub mag: i32,
        pub center_x: i32,
        pub width: i32,
    }
    impl<'a> Default for MiniMapArgs {
        #[inline]
        fn default() -> Self {
            MiniMapArgs {
                center_y: 0,
                height: 0,
                mag: 0,
                center_x: 0,
                width: 0,
            }
        }
    }

    pub struct MiniMapBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MiniMapBuilder<'a, 'b> {
        #[inline]
        pub fn add_center_y(&mut self, center_y: i32) {
            self.fbb_
                .push_slot::<i32>(MiniMap::VT_CENTER_Y, center_y, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: i32) {
            self.fbb_.push_slot::<i32>(MiniMap::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn add_mag(&mut self, mag: i32) {
            self.fbb_.push_slot::<i32>(MiniMap::VT_MAG, mag, 0);
        }
        #[inline]
        pub fn add_center_x(&mut self, center_x: i32) {
            self.fbb_
                .push_slot::<i32>(MiniMap::VT_CENTER_X, center_x, 0);
        }
        #[inline]
        pub fn add_width(&mut self, width: i32) {
            self.fbb_.push_slot::<i32>(MiniMap::VT_WIDTH, width, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MiniMapBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MiniMapBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MiniMap<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MiniMap<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MiniMap");
            ds.field("center_y", &self.center_y());
            ds.field("height", &self.height());
            ds.field("mag", &self.mag());
            ds.field("center_x", &self.center_x());
            ds.field("width", &self.width());
            ds.finish()
        }
    }
    pub enum MapOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Map<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Map<'a> {
        type Inner = Map<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Map<'a> {
        pub const VT_INFO: flatbuffers::VOffsetT = 4;
        pub const VT_LADDER_ROPE: flatbuffers::VOffsetT = 6;
        pub const VT_LIFE: flatbuffers::VOffsetT = 8;
        pub const VT_PORTAL: flatbuffers::VOffsetT = 10;
        pub const VT_SEAT: flatbuffers::VOffsetT = 12;
        pub const VT_EXTRA: flatbuffers::VOffsetT = 14;
        pub const VT_FOOTHOLD: flatbuffers::VOffsetT = 16;
        pub const VT_REACTOR: flatbuffers::VOffsetT = 18;
        pub const VT_MINI_MAP: flatbuffers::VOffsetT = 20;
        pub const VT_BACK: flatbuffers::VOffsetT = 22;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Map { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MapArgs<'args>,
        ) -> flatbuffers::WIPOffset<Map<'bldr>> {
            let mut builder = MapBuilder::new(_fbb);
            if let Some(x) = args.back {
                builder.add_back(x);
            }
            if let Some(x) = args.mini_map {
                builder.add_mini_map(x);
            }
            if let Some(x) = args.reactor {
                builder.add_reactor(x);
            }
            if let Some(x) = args.foothold {
                builder.add_foothold(x);
            }
            if let Some(x) = args.extra {
                builder.add_extra(x);
            }
            if let Some(x) = args.seat {
                builder.add_seat(x);
            }
            if let Some(x) = args.portal {
                builder.add_portal(x);
            }
            if let Some(x) = args.life {
                builder.add_life(x);
            }
            if let Some(x) = args.ladder_rope {
                builder.add_ladder_rope(x);
            }
            if let Some(x) = args.info {
                builder.add_info(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn info(&self) -> Option<Info<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Info>>(Map::VT_INFO, None)
        }
        #[inline]
        pub fn ladder_rope(&self) -> Option<LadderRope<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<LadderRope>>(Map::VT_LADDER_ROPE, None)
        }
        #[inline]
        pub fn life(&self) -> Option<Life<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Life>>(Map::VT_LIFE, None)
        }
        #[inline]
        pub fn portal(&self) -> Option<Portal<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Portal>>(Map::VT_PORTAL, None)
        }
        #[inline]
        pub fn seat(&self) -> Option<Seat<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Seat>>(Map::VT_SEAT, None)
        }
        #[inline]
        pub fn extra(&self) -> Option<Extra<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Extra>>(Map::VT_EXTRA, None)
        }
        #[inline]
        pub fn foothold(&self) -> Option<Foothold<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Foothold>>(Map::VT_FOOTHOLD, None)
        }
        #[inline]
        pub fn reactor(&self) -> Option<Reactor<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Reactor>>(Map::VT_REACTOR, None)
        }
        #[inline]
        pub fn mini_map(&self) -> Option<MiniMap<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<MiniMap>>(Map::VT_MINI_MAP, None)
        }
        #[inline]
        pub fn back(&self) -> Option<Back<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Back>>(Map::VT_BACK, None)
        }
    }

    impl flatbuffers::Verifiable for Map<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Info>>("info", Self::VT_INFO, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<LadderRope>>(
                    "ladder_rope",
                    Self::VT_LADDER_ROPE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Life>>("life", Self::VT_LIFE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Portal>>(
                    "portal",
                    Self::VT_PORTAL,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Seat>>("seat", Self::VT_SEAT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Extra>>("extra", Self::VT_EXTRA, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Foothold>>(
                    "foothold",
                    Self::VT_FOOTHOLD,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Reactor>>(
                    "reactor",
                    Self::VT_REACTOR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<MiniMap>>(
                    "mini_map",
                    Self::VT_MINI_MAP,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<Back>>("back", Self::VT_BACK, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MapArgs<'a> {
        pub info: Option<flatbuffers::WIPOffset<Info<'a>>>,
        pub ladder_rope: Option<flatbuffers::WIPOffset<LadderRope<'a>>>,
        pub life: Option<flatbuffers::WIPOffset<Life<'a>>>,
        pub portal: Option<flatbuffers::WIPOffset<Portal<'a>>>,
        pub seat: Option<flatbuffers::WIPOffset<Seat<'a>>>,
        pub extra: Option<flatbuffers::WIPOffset<Extra<'a>>>,
        pub foothold: Option<flatbuffers::WIPOffset<Foothold<'a>>>,
        pub reactor: Option<flatbuffers::WIPOffset<Reactor<'a>>>,
        pub mini_map: Option<flatbuffers::WIPOffset<MiniMap<'a>>>,
        pub back: Option<flatbuffers::WIPOffset<Back<'a>>>,
    }
    impl<'a> Default for MapArgs<'a> {
        #[inline]
        fn default() -> Self {
            MapArgs {
                info: None,
                ladder_rope: None,
                life: None,
                portal: None,
                seat: None,
                extra: None,
                foothold: None,
                reactor: None,
                mini_map: None,
                back: None,
            }
        }
    }

    pub struct MapBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MapBuilder<'a, 'b> {
        #[inline]
        pub fn add_info(&mut self, info: flatbuffers::WIPOffset<Info<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Info>>(Map::VT_INFO, info);
        }
        #[inline]
        pub fn add_ladder_rope(&mut self, ladder_rope: flatbuffers::WIPOffset<LadderRope<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<LadderRope>>(
                    Map::VT_LADDER_ROPE,
                    ladder_rope,
                );
        }
        #[inline]
        pub fn add_life(&mut self, life: flatbuffers::WIPOffset<Life<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Life>>(Map::VT_LIFE, life);
        }
        #[inline]
        pub fn add_portal(&mut self, portal: flatbuffers::WIPOffset<Portal<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Portal>>(Map::VT_PORTAL, portal);
        }
        #[inline]
        pub fn add_seat(&mut self, seat: flatbuffers::WIPOffset<Seat<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Seat>>(Map::VT_SEAT, seat);
        }
        #[inline]
        pub fn add_extra(&mut self, extra: flatbuffers::WIPOffset<Extra<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Extra>>(Map::VT_EXTRA, extra);
        }
        #[inline]
        pub fn add_foothold(&mut self, foothold: flatbuffers::WIPOffset<Foothold<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Foothold>>(Map::VT_FOOTHOLD, foothold);
        }
        #[inline]
        pub fn add_reactor(&mut self, reactor: flatbuffers::WIPOffset<Reactor<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Reactor>>(Map::VT_REACTOR, reactor);
        }
        #[inline]
        pub fn add_mini_map(&mut self, mini_map: flatbuffers::WIPOffset<MiniMap<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<MiniMap>>(Map::VT_MINI_MAP, mini_map);
        }
        #[inline]
        pub fn add_back(&mut self, back: flatbuffers::WIPOffset<Back<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Back>>(Map::VT_BACK, back);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MapBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MapBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Map<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Map<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Map");
            ds.field("info", &self.info());
            ds.field("ladder_rope", &self.ladder_rope());
            ds.field("life", &self.life());
            ds.field("portal", &self.portal());
            ds.field("seat", &self.seat());
            ds.field("extra", &self.extra());
            ds.field("foothold", &self.foothold());
            ds.field("reactor", &self.reactor());
            ds.field("mini_map", &self.mini_map());
            ds.field("back", &self.back());
            ds.finish()
        }
    }
    pub enum InfoOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Info<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Info<'a> {
        type Inner = Info<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf, loc },
            }
        }
    }

    impl<'a> Info<'a> {
        pub const VT_RETURN_MAP: flatbuffers::VOffsetT = 4;
        pub const VT_CLOUD: flatbuffers::VOffsetT = 6;
        pub const VT_MAP_DESC: flatbuffers::VOffsetT = 8;
        pub const VT_SWIM: flatbuffers::VOffsetT = 10;
        pub const VT_NO_MAP_CMD: flatbuffers::VOffsetT = 12;
        pub const VT_HIDE_MINIMAP: flatbuffers::VOffsetT = 14;
        pub const VT_VR_BOTTOM: flatbuffers::VOffsetT = 16;
        pub const VT_BGM: flatbuffers::VOffsetT = 18;
        pub const VT_LB_SIDE: flatbuffers::VOffsetT = 20;
        pub const VT_T_S: flatbuffers::VOffsetT = 22;
        pub const VT_VR_RIGHT: flatbuffers::VOffsetT = 24;
        pub const VT_MOB_RATE: flatbuffers::VOffsetT = 26;
        pub const VT_MOVE_LIMIT: flatbuffers::VOffsetT = 28;
        pub const VT_FORBID_FALL_DOWN: flatbuffers::VOffsetT = 30;
        pub const VT_FIELD_LIMIT: flatbuffers::VOffsetT = 32;
        pub const VT_VR_LEFT: flatbuffers::VOffsetT = 34;
        pub const VT_MAP_MARK: flatbuffers::VOffsetT = 36;
        pub const VT_ON_FIRST_USER_ENTER: flatbuffers::VOffsetT = 38;
        pub const VT_VERSION: flatbuffers::VOffsetT = 40;
        pub const VT_TOWN: flatbuffers::VOffsetT = 42;
        pub const VT_FLY: flatbuffers::VOffsetT = 44;
        pub const VT_LB_BOTTOM: flatbuffers::VOffsetT = 46;
        pub const VT_FORCED_RETURN: flatbuffers::VOffsetT = 48;
        pub const VT_ON_USER_ENTER: flatbuffers::VOffsetT = 50;
        pub const VT_LB_TOP: flatbuffers::VOffsetT = 52;
        pub const VT_T_S_MAG: flatbuffers::VOffsetT = 54;
        pub const VT_VR_TOP: flatbuffers::VOffsetT = 56;

        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Info { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args InfoArgs<'args>,
        ) -> flatbuffers::WIPOffset<Info<'bldr>> {
            let mut builder = InfoBuilder::new(_fbb);
            builder.add_vr_top(args.vr_top);
            builder.add_t_s_mag(args.t_s_mag);
            builder.add_lb_top(args.lb_top);
            if let Some(x) = args.on_user_enter {
                builder.add_on_user_enter(x);
            }
            builder.add_forced_return(args.forced_return);
            builder.add_lb_bottom(args.lb_bottom);
            builder.add_fly(args.fly);
            builder.add_town(args.town);
            builder.add_version(args.version);
            if let Some(x) = args.on_first_user_enter {
                builder.add_on_first_user_enter(x);
            }
            if let Some(x) = args.map_mark {
                builder.add_map_mark(x);
            }
            builder.add_vr_left(args.vr_left);
            builder.add_field_limit(args.field_limit);
            builder.add_forbid_fall_down(args.forbid_fall_down);
            builder.add_move_limit(args.move_limit);
            builder.add_mob_rate(args.mob_rate);
            builder.add_vr_right(args.vr_right);
            if let Some(x) = args.t_s {
                builder.add_t_s(x);
            }
            builder.add_lb_side(args.lb_side);
            if let Some(x) = args.bgm {
                builder.add_bgm(x);
            }
            builder.add_vr_bottom(args.vr_bottom);
            builder.add_hide_minimap(args.hide_minimap);
            builder.add_no_map_cmd(args.no_map_cmd);
            builder.add_swim(args.swim);
            if let Some(x) = args.map_desc {
                builder.add_map_desc(x);
            }
            builder.add_cloud(args.cloud);
            builder.add_return_map(args.return_map);
            builder.finish()
        }

        #[inline]
        pub fn return_map(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_RETURN_MAP, Some(0)).unwrap()
        }
        #[inline]
        pub fn cloud(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_CLOUD, Some(0)).unwrap()
        }
        #[inline]
        pub fn map_desc(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Info::VT_MAP_DESC, None)
        }
        #[inline]
        pub fn swim(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_SWIM, Some(0)).unwrap()
        }
        #[inline]
        pub fn no_map_cmd(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_NO_MAP_CMD, Some(0)).unwrap()
        }
        #[inline]
        pub fn hide_minimap(&self) -> i32 {
            self._tab
                .get::<i32>(Info::VT_HIDE_MINIMAP, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn vr_bottom(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_VR_BOTTOM, Some(0)).unwrap()
        }
        #[inline]
        pub fn bgm(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Info::VT_BGM, None)
        }
        #[inline]
        pub fn lb_side(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_LB_SIDE, Some(0)).unwrap()
        }
        #[inline]
        pub fn t_s(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Info::VT_T_S, None)
        }
        #[inline]
        pub fn vr_right(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_VR_RIGHT, Some(0)).unwrap()
        }
        #[inline]
        pub fn mob_rate(&self) -> f32 {
            self._tab.get::<f32>(Info::VT_MOB_RATE, Some(0.0)).unwrap()
        }
        #[inline]
        pub fn move_limit(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_MOVE_LIMIT, Some(0)).unwrap()
        }
        #[inline]
        pub fn forbid_fall_down(&self) -> i32 {
            self._tab
                .get::<i32>(Info::VT_FORBID_FALL_DOWN, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn field_limit(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_FIELD_LIMIT, Some(0)).unwrap()
        }
        #[inline]
        pub fn vr_left(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_VR_LEFT, Some(0)).unwrap()
        }
        #[inline]
        pub fn map_mark(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Info::VT_MAP_MARK, None)
        }
        #[inline]
        pub fn on_first_user_enter(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Info::VT_ON_FIRST_USER_ENTER, None)
        }
        #[inline]
        pub fn version(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_VERSION, Some(0)).unwrap()
        }
        #[inline]
        pub fn town(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_TOWN, Some(0)).unwrap()
        }
        #[inline]
        pub fn fly(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_FLY, Some(0)).unwrap()
        }
        #[inline]
        pub fn lb_bottom(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_LB_BOTTOM, Some(0)).unwrap()
        }
        #[inline]
        pub fn forced_return(&self) -> i32 {
            self._tab
                .get::<i32>(Info::VT_FORCED_RETURN, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn on_user_enter(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Info::VT_ON_USER_ENTER, None)
        }
        #[inline]
        pub fn lb_top(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_LB_TOP, Some(0)).unwrap()
        }
        #[inline]
        pub fn t_s_mag(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_T_S_MAG, Some(0)).unwrap()
        }
        #[inline]
        pub fn vr_top(&self) -> i32 {
            self._tab.get::<i32>(Info::VT_VR_TOP, Some(0)).unwrap()
        }
    }

    impl flatbuffers::Verifiable for Info<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("return_map", Self::VT_RETURN_MAP, false)?
                .visit_field::<i32>("cloud", Self::VT_CLOUD, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "map_desc",
                    Self::VT_MAP_DESC,
                    false,
                )?
                .visit_field::<i32>("swim", Self::VT_SWIM, false)?
                .visit_field::<i32>("no_map_cmd", Self::VT_NO_MAP_CMD, false)?
                .visit_field::<i32>("hide_minimap", Self::VT_HIDE_MINIMAP, false)?
                .visit_field::<i32>("vr_bottom", Self::VT_VR_BOTTOM, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("bgm", Self::VT_BGM, false)?
                .visit_field::<i32>("lb_side", Self::VT_LB_SIDE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("t_s", Self::VT_T_S, false)?
                .visit_field::<i32>("vr_right", Self::VT_VR_RIGHT, false)?
                .visit_field::<f32>("mob_rate", Self::VT_MOB_RATE, false)?
                .visit_field::<i32>("move_limit", Self::VT_MOVE_LIMIT, false)?
                .visit_field::<i32>("forbid_fall_down", Self::VT_FORBID_FALL_DOWN, false)?
                .visit_field::<i32>("field_limit", Self::VT_FIELD_LIMIT, false)?
                .visit_field::<i32>("vr_left", Self::VT_VR_LEFT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "map_mark",
                    Self::VT_MAP_MARK,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "on_first_user_enter",
                    Self::VT_ON_FIRST_USER_ENTER,
                    false,
                )?
                .visit_field::<i32>("version", Self::VT_VERSION, false)?
                .visit_field::<i32>("town", Self::VT_TOWN, false)?
                .visit_field::<i32>("fly", Self::VT_FLY, false)?
                .visit_field::<i32>("lb_bottom", Self::VT_LB_BOTTOM, false)?
                .visit_field::<i32>("forced_return", Self::VT_FORCED_RETURN, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "on_user_enter",
                    Self::VT_ON_USER_ENTER,
                    false,
                )?
                .visit_field::<i32>("lb_top", Self::VT_LB_TOP, false)?
                .visit_field::<i32>("t_s_mag", Self::VT_T_S_MAG, false)?
                .visit_field::<i32>("vr_top", Self::VT_VR_TOP, false)?
                .finish();
            Ok(())
        }
    }
    pub struct InfoArgs<'a> {
        pub return_map: i32,
        pub cloud: i32,
        pub map_desc: Option<flatbuffers::WIPOffset<&'a str>>,
        pub swim: i32,
        pub no_map_cmd: i32,
        pub hide_minimap: i32,
        pub vr_bottom: i32,
        pub bgm: Option<flatbuffers::WIPOffset<&'a str>>,
        pub lb_side: i32,
        pub t_s: Option<flatbuffers::WIPOffset<&'a str>>,
        pub vr_right: i32,
        pub mob_rate: f32,
        pub move_limit: i32,
        pub forbid_fall_down: i32,
        pub field_limit: i32,
        pub vr_left: i32,
        pub map_mark: Option<flatbuffers::WIPOffset<&'a str>>,
        pub on_first_user_enter: Option<flatbuffers::WIPOffset<&'a str>>,
        pub version: i32,
        pub town: i32,
        pub fly: i32,
        pub lb_bottom: i32,
        pub forced_return: i32,
        pub on_user_enter: Option<flatbuffers::WIPOffset<&'a str>>,
        pub lb_top: i32,
        pub t_s_mag: i32,
        pub vr_top: i32,
    }
    impl<'a> Default for InfoArgs<'a> {
        #[inline]
        fn default() -> Self {
            InfoArgs {
                return_map: 0,
                cloud: 0,
                map_desc: None,
                swim: 0,
                no_map_cmd: 0,
                hide_minimap: 0,
                vr_bottom: 0,
                bgm: None,
                lb_side: 0,
                t_s: None,
                vr_right: 0,
                mob_rate: 0.0,
                move_limit: 0,
                forbid_fall_down: 0,
                field_limit: 0,
                vr_left: 0,
                map_mark: None,
                on_first_user_enter: None,
                version: 0,
                town: 0,
                fly: 0,
                lb_bottom: 0,
                forced_return: 0,
                on_user_enter: None,
                lb_top: 0,
                t_s_mag: 0,
                vr_top: 0,
            }
        }
    }

    pub struct InfoBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> InfoBuilder<'a, 'b> {
        #[inline]
        pub fn add_return_map(&mut self, return_map: i32) {
            self.fbb_
                .push_slot::<i32>(Info::VT_RETURN_MAP, return_map, 0);
        }
        #[inline]
        pub fn add_cloud(&mut self, cloud: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_CLOUD, cloud, 0);
        }
        #[inline]
        pub fn add_map_desc(&mut self, map_desc: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Info::VT_MAP_DESC, map_desc);
        }
        #[inline]
        pub fn add_swim(&mut self, swim: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_SWIM, swim, 0);
        }
        #[inline]
        pub fn add_no_map_cmd(&mut self, no_map_cmd: i32) {
            self.fbb_
                .push_slot::<i32>(Info::VT_NO_MAP_CMD, no_map_cmd, 0);
        }
        #[inline]
        pub fn add_hide_minimap(&mut self, hide_minimap: i32) {
            self.fbb_
                .push_slot::<i32>(Info::VT_HIDE_MINIMAP, hide_minimap, 0);
        }
        #[inline]
        pub fn add_vr_bottom(&mut self, vr_bottom: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_VR_BOTTOM, vr_bottom, 0);
        }
        #[inline]
        pub fn add_bgm(&mut self, bgm: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Info::VT_BGM, bgm);
        }
        #[inline]
        pub fn add_lb_side(&mut self, lb_side: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_LB_SIDE, lb_side, 0);
        }
        #[inline]
        pub fn add_t_s(&mut self, t_s: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Info::VT_T_S, t_s);
        }
        #[inline]
        pub fn add_vr_right(&mut self, vr_right: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_VR_RIGHT, vr_right, 0);
        }
        #[inline]
        pub fn add_mob_rate(&mut self, mob_rate: f32) {
            self.fbb_.push_slot::<f32>(Info::VT_MOB_RATE, mob_rate, 0.0);
        }
        #[inline]
        pub fn add_move_limit(&mut self, move_limit: i32) {
            self.fbb_
                .push_slot::<i32>(Info::VT_MOVE_LIMIT, move_limit, 0);
        }
        #[inline]
        pub fn add_forbid_fall_down(&mut self, forbid_fall_down: i32) {
            self.fbb_
                .push_slot::<i32>(Info::VT_FORBID_FALL_DOWN, forbid_fall_down, 0);
        }
        #[inline]
        pub fn add_field_limit(&mut self, field_limit: i32) {
            self.fbb_
                .push_slot::<i32>(Info::VT_FIELD_LIMIT, field_limit, 0);
        }
        #[inline]
        pub fn add_vr_left(&mut self, vr_left: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_VR_LEFT, vr_left, 0);
        }
        #[inline]
        pub fn add_map_mark(&mut self, map_mark: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Info::VT_MAP_MARK, map_mark);
        }
        #[inline]
        pub fn add_on_first_user_enter(
            &mut self,
            on_first_user_enter: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Info::VT_ON_FIRST_USER_ENTER,
                on_first_user_enter,
            );
        }
        #[inline]
        pub fn add_version(&mut self, version: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_VERSION, version, 0);
        }
        #[inline]
        pub fn add_town(&mut self, town: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_TOWN, town, 0);
        }
        #[inline]
        pub fn add_fly(&mut self, fly: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_FLY, fly, 0);
        }
        #[inline]
        pub fn add_lb_bottom(&mut self, lb_bottom: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_LB_BOTTOM, lb_bottom, 0);
        }
        #[inline]
        pub fn add_forced_return(&mut self, forced_return: i32) {
            self.fbb_
                .push_slot::<i32>(Info::VT_FORCED_RETURN, forced_return, 0);
        }
        #[inline]
        pub fn add_on_user_enter(&mut self, on_user_enter: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Info::VT_ON_USER_ENTER,
                on_user_enter,
            );
        }
        #[inline]
        pub fn add_lb_top(&mut self, lb_top: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_LB_TOP, lb_top, 0);
        }
        #[inline]
        pub fn add_t_s_mag(&mut self, t_s_mag: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_T_S_MAG, t_s_mag, 0);
        }
        #[inline]
        pub fn add_vr_top(&mut self, vr_top: i32) {
            self.fbb_.push_slot::<i32>(Info::VT_VR_TOP, vr_top, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InfoBuilder<'a, 'b> {
            let start = _fbb.start_table();
            InfoBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Info<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Info<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Info");
            ds.field("return_map", &self.return_map());
            ds.field("cloud", &self.cloud());
            ds.field("map_desc", &self.map_desc());
            ds.field("swim", &self.swim());
            ds.field("no_map_cmd", &self.no_map_cmd());
            ds.field("hide_minimap", &self.hide_minimap());
            ds.field("vr_bottom", &self.vr_bottom());
            ds.field("bgm", &self.bgm());
            ds.field("lb_side", &self.lb_side());
            ds.field("t_s", &self.t_s());
            ds.field("vr_right", &self.vr_right());
            ds.field("mob_rate", &self.mob_rate());
            ds.field("move_limit", &self.move_limit());
            ds.field("forbid_fall_down", &self.forbid_fall_down());
            ds.field("field_limit", &self.field_limit());
            ds.field("vr_left", &self.vr_left());
            ds.field("map_mark", &self.map_mark());
            ds.field("on_first_user_enter", &self.on_first_user_enter());
            ds.field("version", &self.version());
            ds.field("town", &self.town());
            ds.field("fly", &self.fly());
            ds.field("lb_bottom", &self.lb_bottom());
            ds.field("forced_return", &self.forced_return());
            ds.field("on_user_enter", &self.on_user_enter());
            ds.field("lb_top", &self.lb_top());
            ds.field("t_s_mag", &self.t_s_mag());
            ds.field("vr_top", &self.vr_top());
            ds.finish()
        }
    }
} // pub mod reMember
